import request from 'supertest';
import express from 'express';

// Mock Firebase Admin
jest.mock('firebase-admin', () => ({
  initializeApp: jest.fn(),
  credential: {
    applicationDefault: jest.fn()
  },
  firestore: jest.fn(() => ({
    collection: jest.fn()
  }))
}));

// Mock Firestore
const mockFirestore = {
  collection: jest.fn(() => ({
    get: jest.fn(),
    where: jest.fn(() => ({
      get: jest.fn()
    })),
    orderBy: jest.fn(() => ({
      get: jest.fn()
    }))
  }))
};

jest.mock('firebase-admin', () => ({
  initializeApp: jest.fn(),
  credential: {
    applicationDefault: jest.fn()
  },
  firestore: jest.fn(() => mockFirestore)
}));

// Mock CVE data
const mockCVEs = [
  {
    id: 'CVE-2023-1234',
    cvssScore: 9.8,
    affectedSoftware: ['Apache Log4j', 'Spring Boot'],
    publicationDate: '2023-01-15T10:00:00Z',
    description: 'Critical vulnerability in logging framework',
    severity: 'Critical'
  },
  {
    id: 'CVE-2023-5678',
    cvssScore: 8.5,
    affectedSoftware: ['OpenSSL', 'Node.js'],
    publicationDate: '2023-02-20T14:30:00Z',
    description: 'High severity vulnerability in cryptographic library',
    severity: 'High'
  },
  {
    id: 'CVE-2023-9012',
    cvssScore: 7.2,
    affectedSoftware: ['MySQL', 'PostgreSQL'],
    publicationDate: '2023-03-10T09:15:00Z',
    description: 'Medium severity database vulnerability',
    severity: 'Medium'
  },
  {
    id: 'CVE-2023-3456',
    cvssScore: 9.1,
    affectedSoftware: ['Docker', 'Kubernetes'],
    publicationDate: '2023-04-05T16:45:00Z',
    description: 'Critical container orchestration vulnerability',
    severity: 'Critical'
  },
  {
    id: 'CVE-2023-7890',
    cvssScore: 6.5,
    affectedSoftware: ['Redis', 'MongoDB'],
    publicationDate: '2023-05-12T11:20:00Z',
    description: 'Medium severity NoSQL database vulnerability',
    severity: 'Medium'
  }
];

// Mock users for authentication
const mockUsers = [
  {
    userId: 'admin-user-id',
    email: 'admin@example.com',
    firstName: 'Admin',
    lastName: 'User',
    role: 'admin',
    organizationId: 'org-1'
  },
  {
    userId: 'editor-user-id',
    email: 'editor@example.com',
    firstName: 'Editor',
    lastName: 'User',
    role: 'editor',
    organizationId: 'org-1'
  },
  {
    userId: 'viewer-user-id',
    email: 'viewer@example.com',
    firstName: 'Viewer',
    lastName: 'User',
    role: 'viewer',
    organizationId: 'org-1'
  }
];

// Mock authentication middleware
const mockAuthMiddleware = (req: any, res: any, next: any) => {
  const authHeader = req.headers.authorization;
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({
      error: 'No valid authorization header found',
      message: 'Authorization header is required'
    });
  }

  const token = authHeader.substring(7);
  
  // Mock different users based on token
  if (token === 'admin-token') {
    req.user = mockUsers[0]; // admin user
  } else if (token === 'editor-token') {
    req.user = mockUsers[1]; // editor user
  } else if (token === 'viewer-token') {
    req.user = mockUsers[2]; // viewer user
  } else {
    return res.status(401).json({
      error: 'Invalid token',
      message: 'Token is invalid or expired'
    });
  }
  
  next();
};

// Create Express app for testing
const app = express();
app.use(express.json());

// Mock CVE endpoints
app.get('/cves', mockAuthMiddleware, (req, res) => {
  const { cvssMin } = req.query;
  
  let filteredCVEs = [...mockCVEs];
  
  // FR06: Filter by CVSS score if specified
  if (cvssMin) {
    const minScore = parseFloat(cvssMin as string);
    if (!isNaN(minScore)) {
      filteredCVEs = filteredCVEs.filter(cve => cve.cvssScore >= minScore);
    }
  }
  
  res.status(200).json({
    cves: filteredCVEs,
    total: filteredCVEs.length
  });
});

app.get('/cves/:cveId', mockAuthMiddleware, (req, res) => {
  const { cveId } = req.params;
  
  const cve = mockCVEs.find(c => c.id === cveId);
  
  if (!cve) {
    return res.status(404).json({
      error: 'CVE not found',
      message: 'The specified CVE does not exist'
    });
  }
  
  // FR07: Return detailed CVE information
  res.status(200).json({
    cve: {
      id: cve.id,
      cvssScore: cve.cvssScore,
      affectedSoftware: cve.affectedSoftware,
      publicationDate: cve.publicationDate,
      description: cve.description,
      severity: cve.severity
    }
  });
});

describe('CVE Management & Viewing', () => {
  describe('FR06: High CVSS CVE Retrieval', () => {
    it('should retrieve all CVEs with CVSS score 8 or above', async () => {
      const response = await request(app)
        .get('/cves?cvssMin=8')
        .set('Authorization', 'Bearer admin-token')
        .expect(200);

      expect(response.body.cves).toHaveLength(3); // CVE-2023-1234 (9.8), CVE-2023-5678 (8.5), CVE-2023-3456 (9.1)
      expect(response.body.total).toBe(3);
      
      // Verify all returned CVEs have CVSS >= 8
      response.body.cves.forEach((cve: any) => {
        expect(cve.cvssScore).toBeGreaterThanOrEqual(8);
      });
      
      // Verify specific high CVSS CVEs are included
      const cveIds = response.body.cves.map((cve: any) => cve.id);
      expect(cveIds).toContain('CVE-2023-1234'); // 9.8
      expect(cveIds).toContain('CVE-2023-5678'); // 8.5
      expect(cveIds).toContain('CVE-2023-3456'); // 9.1
    });

    it('should retrieve all CVEs when no CVSS filter is applied', async () => {
      const response = await request(app)
        .get('/cves')
        .set('Authorization', 'Bearer admin-token')
        .expect(200);

      expect(response.body.cves).toHaveLength(5); // All CVEs
      expect(response.body.total).toBe(5);
    });

    it('should return empty array when CVSS filter excludes all CVEs', async () => {
      const response = await request(app)
        .get('/cves?cvssMin=10')
        .set('Authorization', 'Bearer admin-token')
        .expect(200);

      expect(response.body.cves).toHaveLength(0);
      expect(response.body.total).toBe(0);
    });

    it('should handle invalid CVSS filter gracefully', async () => {
      const response = await request(app)
        .get('/cves?cvssMin=invalid')
        .set('Authorization', 'Bearer admin-token')
        .expect(200);

      expect(response.body.cves).toHaveLength(5); // Should return all CVEs when filter is invalid
      expect(response.body.total).toBe(5);
    });
  });

  describe('FR07: CVE Detail Viewing', () => {
    it('should return detailed CVE information including CVSS score, affected software, and publication date', async () => {
      const response = await request(app)
        .get('/cves/CVE-2023-1234')
        .set('Authorization', 'Bearer admin-token')
        .expect(200);

      const cve = response.body.cve;
      
      expect(cve.id).toBe('CVE-2023-1234');
      expect(cve.cvssScore).toBe(9.8);
      expect(cve.affectedSoftware).toEqual(['Apache Log4j', 'Spring Boot']);
      expect(cve.publicationDate).toBe('2023-01-15T10:00:00Z');
      expect(cve.description).toBe('Critical vulnerability in logging framework');
      expect(cve.severity).toBe('Critical');
    });

    it('should return 404 for non-existent CVE', async () => {
      const response = await request(app)
        .get('/cves/CVE-2023-9999')
        .set('Authorization', 'Bearer admin-token')
        .expect(404);

      expect(response.body.error).toBe('CVE not found');
      expect(response.body.message).toBe('The specified CVE does not exist');
    });

    it('should allow all authenticated users to view CVE details', async () => {
      // Test admin access
      const adminResponse = await request(app)
        .get('/cves/CVE-2023-5678')
        .set('Authorization', 'Bearer admin-token')
        .expect(200);
      
      expect(adminResponse.body.cve.id).toBe('CVE-2023-5678');

      // Test editor access
      const editorResponse = await request(app)
        .get('/cves/CVE-2023-5678')
        .set('Authorization', 'Bearer editor-token')
        .expect(200);
      
      expect(editorResponse.body.cve.id).toBe('CVE-2023-5678');

      // Test viewer access
      const viewerResponse = await request(app)
        .get('/cves/CVE-2023-5678')
        .set('Authorization', 'Bearer viewer-token')
        .expect(200);
      
      expect(viewerResponse.body.cve.id).toBe('CVE-2023-5678');
    });
  });
}); 